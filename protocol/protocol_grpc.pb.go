// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package protocol

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// YlccClient is the client API for Ylcc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type YlccClient interface {
	// キャッシュされているvideo情報を返す
	GetVideo(ctx context.Context, in *GetVideoRequest, opts ...grpc.CallOption) (*GetVideoResponse, error)
	// 配信中のライブチャットの収集を開始する
	// 収集したメッセージはキャッシュされる
	StartCollectionActiveLiveChat(ctx context.Context, in *StartCollectionActiveLiveChatRequest, opts ...grpc.CallOption) (*StartCollectionActiveLiveChatResponse, error)
	// 収集中のライブチャットのメッセージをリアルタイムに返す
	PollActiveLiveChat(ctx context.Context, in *PollActiveLiveChatRequest, opts ...grpc.CallOption) (Ylcc_PollActiveLiveChatClient, error)
	// 収集後キャッシュしたライブチャットのメッセージを返す
	// すでに収集中はエラーを返す
	GetCachedActiveLiveChat(ctx context.Context, in *GetCachedActiveLiveChatRequest, opts ...grpc.CallOption) (*GetCachedActiveLiveChatResponse, error)
	// アーカイブのライブチャットの収集を開始する
	// すでに収集中はエラーを返す
	StartCollectionArchiveLiveChat(ctx context.Context, in *StartCollectionArchiveLiveChatRequest, opts ...grpc.CallOption) (*StartCollectionArchiveLiveChatResponse, error)
	// アーカイブのライブチャットのメッセージを返す
	// 収集完了していない間はエラーを返す
	GetArchiveLiveChat(ctx context.Context, in *GetArchiveLiveChatRequest, opts ...grpc.CallOption) (*GetArchiveLiveChatResponse, error)
	// 配信中のライブチャットのワードクラウドメッセージの収集を開始する
	// すでに収集中はエラーを返す
	StartCollectionWordCloudMessages(ctx context.Context, in *StartCollectionWordCloudMessagesRequest, opts ...grpc.CallOption) (*StartCollectionWordCloudMessagesResponse, error)
	// 収集中のライブチャットメッセージからword cloudを生成して返す
	GetWordCloud(ctx context.Context, in *GetWordCloudRequest, opts ...grpc.CallOption) (*GetWordCloudResponse, error)
	// 配信中のライブチャットの収集を始めて投票を開始する
	OpenVote(ctx context.Context, in *OpenVoteRequest, opts ...grpc.CallOption) (*OpenVoteResponse, error)
	// 配信中のライブチャットの投票の時間を変更する
	UpdateVoteDuration(ctx context.Context, in *UpdateVoteDurationRequest, opts ...grpc.CallOption) (*UpdateVoteDurationResponse, error)
	// 配信中のライブチャットの投票の現在の結果を取得する
	GetVoteResult(ctx context.Context, in *GetVoteResultRequest, opts ...grpc.CallOption) (*GetVoteResultResponse, error)
	// 配信中のライブチャットの投票を終わる
	CloseVote(ctx context.Context, in *CloseVoteRequest, opts ...grpc.CallOption) (*CloseVoteResponse, error)
	// 配信中のライブチャットのグループ化を開始する
	OpenGrouping(ctx context.Context, in *OpenGroupingRequest, opts ...grpc.CallOption) (*OpenGroupingResponse, error)
	// 配信中のライブチャットのグルーピングを終了する
	CloseGrouping(ctx context.Context, in *CloseGroupingRequest, opts ...grpc.CallOption) (*CloseGroupingResponse, error)
	// 収集中のライブチャットのグルーピングメッセージをリアルタイムに返す
	PollGroupingActiveLiveChat(ctx context.Context, in *PollGroupingActiveLiveChatRequest, opts ...grpc.CallOption) (Ylcc_PollGroupingActiveLiveChatClient, error)
}

type ylccClient struct {
	cc grpc.ClientConnInterface
}

func NewYlccClient(cc grpc.ClientConnInterface) YlccClient {
	return &ylccClient{cc}
}

func (c *ylccClient) GetVideo(ctx context.Context, in *GetVideoRequest, opts ...grpc.CallOption) (*GetVideoResponse, error) {
	out := new(GetVideoResponse)
	err := c.cc.Invoke(ctx, "/ylcc/GetVideo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ylccClient) StartCollectionActiveLiveChat(ctx context.Context, in *StartCollectionActiveLiveChatRequest, opts ...grpc.CallOption) (*StartCollectionActiveLiveChatResponse, error) {
	out := new(StartCollectionActiveLiveChatResponse)
	err := c.cc.Invoke(ctx, "/ylcc/StartCollectionActiveLiveChat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ylccClient) PollActiveLiveChat(ctx context.Context, in *PollActiveLiveChatRequest, opts ...grpc.CallOption) (Ylcc_PollActiveLiveChatClient, error) {
	stream, err := c.cc.NewStream(ctx, &Ylcc_ServiceDesc.Streams[0], "/ylcc/PollActiveLiveChat", opts...)
	if err != nil {
		return nil, err
	}
	x := &ylccPollActiveLiveChatClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Ylcc_PollActiveLiveChatClient interface {
	Recv() (*PollActiveLiveChatResponse, error)
	grpc.ClientStream
}

type ylccPollActiveLiveChatClient struct {
	grpc.ClientStream
}

func (x *ylccPollActiveLiveChatClient) Recv() (*PollActiveLiveChatResponse, error) {
	m := new(PollActiveLiveChatResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ylccClient) GetCachedActiveLiveChat(ctx context.Context, in *GetCachedActiveLiveChatRequest, opts ...grpc.CallOption) (*GetCachedActiveLiveChatResponse, error) {
	out := new(GetCachedActiveLiveChatResponse)
	err := c.cc.Invoke(ctx, "/ylcc/GetCachedActiveLiveChat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ylccClient) StartCollectionArchiveLiveChat(ctx context.Context, in *StartCollectionArchiveLiveChatRequest, opts ...grpc.CallOption) (*StartCollectionArchiveLiveChatResponse, error) {
	out := new(StartCollectionArchiveLiveChatResponse)
	err := c.cc.Invoke(ctx, "/ylcc/StartCollectionArchiveLiveChat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ylccClient) GetArchiveLiveChat(ctx context.Context, in *GetArchiveLiveChatRequest, opts ...grpc.CallOption) (*GetArchiveLiveChatResponse, error) {
	out := new(GetArchiveLiveChatResponse)
	err := c.cc.Invoke(ctx, "/ylcc/GetArchiveLiveChat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ylccClient) StartCollectionWordCloudMessages(ctx context.Context, in *StartCollectionWordCloudMessagesRequest, opts ...grpc.CallOption) (*StartCollectionWordCloudMessagesResponse, error) {
	out := new(StartCollectionWordCloudMessagesResponse)
	err := c.cc.Invoke(ctx, "/ylcc/StartCollectionWordCloudMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ylccClient) GetWordCloud(ctx context.Context, in *GetWordCloudRequest, opts ...grpc.CallOption) (*GetWordCloudResponse, error) {
	out := new(GetWordCloudResponse)
	err := c.cc.Invoke(ctx, "/ylcc/GetWordCloud", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ylccClient) OpenVote(ctx context.Context, in *OpenVoteRequest, opts ...grpc.CallOption) (*OpenVoteResponse, error) {
	out := new(OpenVoteResponse)
	err := c.cc.Invoke(ctx, "/ylcc/OpenVote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ylccClient) UpdateVoteDuration(ctx context.Context, in *UpdateVoteDurationRequest, opts ...grpc.CallOption) (*UpdateVoteDurationResponse, error) {
	out := new(UpdateVoteDurationResponse)
	err := c.cc.Invoke(ctx, "/ylcc/UpdateVoteDuration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ylccClient) GetVoteResult(ctx context.Context, in *GetVoteResultRequest, opts ...grpc.CallOption) (*GetVoteResultResponse, error) {
	out := new(GetVoteResultResponse)
	err := c.cc.Invoke(ctx, "/ylcc/GetVoteResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ylccClient) CloseVote(ctx context.Context, in *CloseVoteRequest, opts ...grpc.CallOption) (*CloseVoteResponse, error) {
	out := new(CloseVoteResponse)
	err := c.cc.Invoke(ctx, "/ylcc/CloseVote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ylccClient) OpenGrouping(ctx context.Context, in *OpenGroupingRequest, opts ...grpc.CallOption) (*OpenGroupingResponse, error) {
	out := new(OpenGroupingResponse)
	err := c.cc.Invoke(ctx, "/ylcc/OpenGrouping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ylccClient) CloseGrouping(ctx context.Context, in *CloseGroupingRequest, opts ...grpc.CallOption) (*CloseGroupingResponse, error) {
	out := new(CloseGroupingResponse)
	err := c.cc.Invoke(ctx, "/ylcc/CloseGrouping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ylccClient) PollGroupingActiveLiveChat(ctx context.Context, in *PollGroupingActiveLiveChatRequest, opts ...grpc.CallOption) (Ylcc_PollGroupingActiveLiveChatClient, error) {
	stream, err := c.cc.NewStream(ctx, &Ylcc_ServiceDesc.Streams[1], "/ylcc/PollGroupingActiveLiveChat", opts...)
	if err != nil {
		return nil, err
	}
	x := &ylccPollGroupingActiveLiveChatClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Ylcc_PollGroupingActiveLiveChatClient interface {
	Recv() (*PollGroupingActiveLiveChatResponse, error)
	grpc.ClientStream
}

type ylccPollGroupingActiveLiveChatClient struct {
	grpc.ClientStream
}

func (x *ylccPollGroupingActiveLiveChatClient) Recv() (*PollGroupingActiveLiveChatResponse, error) {
	m := new(PollGroupingActiveLiveChatResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// YlccServer is the server API for Ylcc service.
// All implementations must embed UnimplementedYlccServer
// for forward compatibility
type YlccServer interface {
	// キャッシュされているvideo情報を返す
	GetVideo(context.Context, *GetVideoRequest) (*GetVideoResponse, error)
	// 配信中のライブチャットの収集を開始する
	// 収集したメッセージはキャッシュされる
	StartCollectionActiveLiveChat(context.Context, *StartCollectionActiveLiveChatRequest) (*StartCollectionActiveLiveChatResponse, error)
	// 収集中のライブチャットのメッセージをリアルタイムに返す
	PollActiveLiveChat(*PollActiveLiveChatRequest, Ylcc_PollActiveLiveChatServer) error
	// 収集後キャッシュしたライブチャットのメッセージを返す
	// すでに収集中はエラーを返す
	GetCachedActiveLiveChat(context.Context, *GetCachedActiveLiveChatRequest) (*GetCachedActiveLiveChatResponse, error)
	// アーカイブのライブチャットの収集を開始する
	// すでに収集中はエラーを返す
	StartCollectionArchiveLiveChat(context.Context, *StartCollectionArchiveLiveChatRequest) (*StartCollectionArchiveLiveChatResponse, error)
	// アーカイブのライブチャットのメッセージを返す
	// 収集完了していない間はエラーを返す
	GetArchiveLiveChat(context.Context, *GetArchiveLiveChatRequest) (*GetArchiveLiveChatResponse, error)
	// 配信中のライブチャットのワードクラウドメッセージの収集を開始する
	// すでに収集中はエラーを返す
	StartCollectionWordCloudMessages(context.Context, *StartCollectionWordCloudMessagesRequest) (*StartCollectionWordCloudMessagesResponse, error)
	// 収集中のライブチャットメッセージからword cloudを生成して返す
	GetWordCloud(context.Context, *GetWordCloudRequest) (*GetWordCloudResponse, error)
	// 配信中のライブチャットの収集を始めて投票を開始する
	OpenVote(context.Context, *OpenVoteRequest) (*OpenVoteResponse, error)
	// 配信中のライブチャットの投票の時間を変更する
	UpdateVoteDuration(context.Context, *UpdateVoteDurationRequest) (*UpdateVoteDurationResponse, error)
	// 配信中のライブチャットの投票の現在の結果を取得する
	GetVoteResult(context.Context, *GetVoteResultRequest) (*GetVoteResultResponse, error)
	// 配信中のライブチャットの投票を終わる
	CloseVote(context.Context, *CloseVoteRequest) (*CloseVoteResponse, error)
	// 配信中のライブチャットのグループ化を開始する
	OpenGrouping(context.Context, *OpenGroupingRequest) (*OpenGroupingResponse, error)
	// 配信中のライブチャットのグルーピングを終了する
	CloseGrouping(context.Context, *CloseGroupingRequest) (*CloseGroupingResponse, error)
	// 収集中のライブチャットのグルーピングメッセージをリアルタイムに返す
	PollGroupingActiveLiveChat(*PollGroupingActiveLiveChatRequest, Ylcc_PollGroupingActiveLiveChatServer) error
	mustEmbedUnimplementedYlccServer()
}

// UnimplementedYlccServer must be embedded to have forward compatible implementations.
type UnimplementedYlccServer struct {
}

func (UnimplementedYlccServer) GetVideo(context.Context, *GetVideoRequest) (*GetVideoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVideo not implemented")
}
func (UnimplementedYlccServer) StartCollectionActiveLiveChat(context.Context, *StartCollectionActiveLiveChatRequest) (*StartCollectionActiveLiveChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartCollectionActiveLiveChat not implemented")
}
func (UnimplementedYlccServer) PollActiveLiveChat(*PollActiveLiveChatRequest, Ylcc_PollActiveLiveChatServer) error {
	return status.Errorf(codes.Unimplemented, "method PollActiveLiveChat not implemented")
}
func (UnimplementedYlccServer) GetCachedActiveLiveChat(context.Context, *GetCachedActiveLiveChatRequest) (*GetCachedActiveLiveChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCachedActiveLiveChat not implemented")
}
func (UnimplementedYlccServer) StartCollectionArchiveLiveChat(context.Context, *StartCollectionArchiveLiveChatRequest) (*StartCollectionArchiveLiveChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartCollectionArchiveLiveChat not implemented")
}
func (UnimplementedYlccServer) GetArchiveLiveChat(context.Context, *GetArchiveLiveChatRequest) (*GetArchiveLiveChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArchiveLiveChat not implemented")
}
func (UnimplementedYlccServer) StartCollectionWordCloudMessages(context.Context, *StartCollectionWordCloudMessagesRequest) (*StartCollectionWordCloudMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartCollectionWordCloudMessages not implemented")
}
func (UnimplementedYlccServer) GetWordCloud(context.Context, *GetWordCloudRequest) (*GetWordCloudResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWordCloud not implemented")
}
func (UnimplementedYlccServer) OpenVote(context.Context, *OpenVoteRequest) (*OpenVoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenVote not implemented")
}
func (UnimplementedYlccServer) UpdateVoteDuration(context.Context, *UpdateVoteDurationRequest) (*UpdateVoteDurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVoteDuration not implemented")
}
func (UnimplementedYlccServer) GetVoteResult(context.Context, *GetVoteResultRequest) (*GetVoteResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVoteResult not implemented")
}
func (UnimplementedYlccServer) CloseVote(context.Context, *CloseVoteRequest) (*CloseVoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseVote not implemented")
}
func (UnimplementedYlccServer) OpenGrouping(context.Context, *OpenGroupingRequest) (*OpenGroupingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenGrouping not implemented")
}
func (UnimplementedYlccServer) CloseGrouping(context.Context, *CloseGroupingRequest) (*CloseGroupingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseGrouping not implemented")
}
func (UnimplementedYlccServer) PollGroupingActiveLiveChat(*PollGroupingActiveLiveChatRequest, Ylcc_PollGroupingActiveLiveChatServer) error {
	return status.Errorf(codes.Unimplemented, "method PollGroupingActiveLiveChat not implemented")
}
func (UnimplementedYlccServer) mustEmbedUnimplementedYlccServer() {}

// UnsafeYlccServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to YlccServer will
// result in compilation errors.
type UnsafeYlccServer interface {
	mustEmbedUnimplementedYlccServer()
}

func RegisterYlccServer(s grpc.ServiceRegistrar, srv YlccServer) {
	s.RegisterService(&Ylcc_ServiceDesc, srv)
}

func _Ylcc_GetVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVideoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YlccServer).GetVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ylcc/GetVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YlccServer).GetVideo(ctx, req.(*GetVideoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ylcc_StartCollectionActiveLiveChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartCollectionActiveLiveChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YlccServer).StartCollectionActiveLiveChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ylcc/StartCollectionActiveLiveChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YlccServer).StartCollectionActiveLiveChat(ctx, req.(*StartCollectionActiveLiveChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ylcc_PollActiveLiveChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PollActiveLiveChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YlccServer).PollActiveLiveChat(m, &ylccPollActiveLiveChatServer{stream})
}

type Ylcc_PollActiveLiveChatServer interface {
	Send(*PollActiveLiveChatResponse) error
	grpc.ServerStream
}

type ylccPollActiveLiveChatServer struct {
	grpc.ServerStream
}

func (x *ylccPollActiveLiveChatServer) Send(m *PollActiveLiveChatResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Ylcc_GetCachedActiveLiveChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCachedActiveLiveChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YlccServer).GetCachedActiveLiveChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ylcc/GetCachedActiveLiveChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YlccServer).GetCachedActiveLiveChat(ctx, req.(*GetCachedActiveLiveChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ylcc_StartCollectionArchiveLiveChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartCollectionArchiveLiveChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YlccServer).StartCollectionArchiveLiveChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ylcc/StartCollectionArchiveLiveChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YlccServer).StartCollectionArchiveLiveChat(ctx, req.(*StartCollectionArchiveLiveChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ylcc_GetArchiveLiveChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArchiveLiveChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YlccServer).GetArchiveLiveChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ylcc/GetArchiveLiveChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YlccServer).GetArchiveLiveChat(ctx, req.(*GetArchiveLiveChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ylcc_StartCollectionWordCloudMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartCollectionWordCloudMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YlccServer).StartCollectionWordCloudMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ylcc/StartCollectionWordCloudMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YlccServer).StartCollectionWordCloudMessages(ctx, req.(*StartCollectionWordCloudMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ylcc_GetWordCloud_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWordCloudRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YlccServer).GetWordCloud(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ylcc/GetWordCloud",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YlccServer).GetWordCloud(ctx, req.(*GetWordCloudRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ylcc_OpenVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenVoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YlccServer).OpenVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ylcc/OpenVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YlccServer).OpenVote(ctx, req.(*OpenVoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ylcc_UpdateVoteDuration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVoteDurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YlccServer).UpdateVoteDuration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ylcc/UpdateVoteDuration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YlccServer).UpdateVoteDuration(ctx, req.(*UpdateVoteDurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ylcc_GetVoteResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVoteResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YlccServer).GetVoteResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ylcc/GetVoteResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YlccServer).GetVoteResult(ctx, req.(*GetVoteResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ylcc_CloseVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseVoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YlccServer).CloseVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ylcc/CloseVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YlccServer).CloseVote(ctx, req.(*CloseVoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ylcc_OpenGrouping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenGroupingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YlccServer).OpenGrouping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ylcc/OpenGrouping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YlccServer).OpenGrouping(ctx, req.(*OpenGroupingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ylcc_CloseGrouping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseGroupingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YlccServer).CloseGrouping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ylcc/CloseGrouping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YlccServer).CloseGrouping(ctx, req.(*CloseGroupingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ylcc_PollGroupingActiveLiveChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PollGroupingActiveLiveChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YlccServer).PollGroupingActiveLiveChat(m, &ylccPollGroupingActiveLiveChatServer{stream})
}

type Ylcc_PollGroupingActiveLiveChatServer interface {
	Send(*PollGroupingActiveLiveChatResponse) error
	grpc.ServerStream
}

type ylccPollGroupingActiveLiveChatServer struct {
	grpc.ServerStream
}

func (x *ylccPollGroupingActiveLiveChatServer) Send(m *PollGroupingActiveLiveChatResponse) error {
	return x.ServerStream.SendMsg(m)
}

// Ylcc_ServiceDesc is the grpc.ServiceDesc for Ylcc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Ylcc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ylcc",
	HandlerType: (*YlccServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVideo",
			Handler:    _Ylcc_GetVideo_Handler,
		},
		{
			MethodName: "StartCollectionActiveLiveChat",
			Handler:    _Ylcc_StartCollectionActiveLiveChat_Handler,
		},
		{
			MethodName: "GetCachedActiveLiveChat",
			Handler:    _Ylcc_GetCachedActiveLiveChat_Handler,
		},
		{
			MethodName: "StartCollectionArchiveLiveChat",
			Handler:    _Ylcc_StartCollectionArchiveLiveChat_Handler,
		},
		{
			MethodName: "GetArchiveLiveChat",
			Handler:    _Ylcc_GetArchiveLiveChat_Handler,
		},
		{
			MethodName: "StartCollectionWordCloudMessages",
			Handler:    _Ylcc_StartCollectionWordCloudMessages_Handler,
		},
		{
			MethodName: "GetWordCloud",
			Handler:    _Ylcc_GetWordCloud_Handler,
		},
		{
			MethodName: "OpenVote",
			Handler:    _Ylcc_OpenVote_Handler,
		},
		{
			MethodName: "UpdateVoteDuration",
			Handler:    _Ylcc_UpdateVoteDuration_Handler,
		},
		{
			MethodName: "GetVoteResult",
			Handler:    _Ylcc_GetVoteResult_Handler,
		},
		{
			MethodName: "CloseVote",
			Handler:    _Ylcc_CloseVote_Handler,
		},
		{
			MethodName: "OpenGrouping",
			Handler:    _Ylcc_OpenGrouping_Handler,
		},
		{
			MethodName: "CloseGrouping",
			Handler:    _Ylcc_CloseGrouping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PollActiveLiveChat",
			Handler:       _Ylcc_PollActiveLiveChat_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PollGroupingActiveLiveChat",
			Handler:       _Ylcc_PollGroupingActiveLiveChat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protocol.proto",
}
